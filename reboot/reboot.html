<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./reboot.css">
    <title>테스트</title>
</head>
<body>
    <h1>리부트 서버 정상화 이후 인구 수</h1>
    <canvas id="chart" width="1000" height="400"></canvas>
    <div class="tooltip" id="tooltip"></div>
</body>
<script>
    const canvas = document.getElementById("chart");
    
    const ctx = canvas.getContext("2d");
    
    const tooltip = document.getElementById("tooltip");
    
    const width = (canvas.width = canvas.offsetWidth);
    const height = (canvas.height = canvas.offsetHeight);
    
    const padding = 50;
    const chartWidth = width - padding * 2;
    const chartHeight = height - padding * 2;

    document.addEventListener("DOMContentLoaded", () => {
        fetch("reboot.csv")
        .then(response => response.text())
        .then(data => {
            const parsedData = parseCSV(data);
            const labels = parsedData.labels;
            const datasets = parsedData.datasets;
            
            const maxValue = Math.max(...datasets.flatMap(dataset => dataset.data));
            const minValue = Math.min(...datasets.flatMap(dataset => dataset.data));

            drawChart(parsedData, labels, datasets, maxValue, minValue);
        })
        .catch(error => console.error("Error Loading the CSV File: ", error));
    });

    function parseCSV(csv) {
        let rows = csv.split("\n").map(row => row.split(","));
        let labels = rows[0].slice(1).map(label => label.trim());
        let datasets = [];
        
        datasets.push({
            label: rows[1][0].trim(),
            data: rows[1].slice(1).map(Number),
            borderColor: "red",
            fill: true,
        })
        datasets.push({
            label: rows[2][0].trim(),
            data: rows[2].slice(1).map(Number),
            borderColor: "blue",
            fill: true,
        })
        return { labels, datasets };
    }
    
    function drawChart(parsedData, labels, datasets, maxValue, minValue) {
        const xStep = chartWidth / (labels.length - 1);
        let progress = 0;
        let animationDuration = 2000;
        let startTime = performance.now();
        let currentPointIndex = 0;

        // 데이터를 캔버스 좌표로 변환
        function getCanvasCoordinates(datasetIndex, index) {
            const data = datasets[datasetIndex].data;
            const x = padding + xStep * index;
            const y = padding + chartHeight - ((data[index] - minValue) / (maxValue - minValue)) * chartHeight;
            return { x, y };
        }

        function drawSmoothLine(datasetIndex, animatedProgress) {
            ctx.beginPath();
            ctx.moveTo(getCanvasCoordinates(datasetIndex, 0).x, getCanvasCoordinates(datasetIndex, 0).y);
            for(let i = 1; i <= currentPointIndex; i++) {
                const previous = getCanvasCoordinates(datasetIndex, i - 1);
                const current = getCanvasCoordinates(datasetIndex, i);

                // 마지막 점 처리
                if (i === currentPointIndex) {
                    const progressX = previous.x + (current.x - previous.x) * animatedProgress;
                    const progressY = previous.y + (current.y - previous.y) * animatedProgress;
                    ctx.lineTo(progressX, progressY); 
                } else {
                    ctx.lineTo(current.x, current.y);
                }
            }
            ctx.strokeStyle = datasets[datasetIndex].borderColor;
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function animateChart(currentTime) {
            const elapsedTime = currentTime - startTime;
            const segmentDuration = animationDuration / (labels.length - 1);
            progress = (elapsedTime % segmentDuration) / segmentDuration;

            if (elapsedTime >= segmentDuration * currentPointIndex && currentPointIndex <= labels.length - 1) {
                currentPointIndex++;
            }

            // 캔버스를 지우고 다시 그리기
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawAxes();
            drawLabels();
            drawGridLines();
            datasets.forEach((_, index) => drawSmoothLine(index, progress));

            if(currentPointIndex < labels.length - 1 || progress < 1) {
               requestAnimationFrame(animateChart);
            }
        }

        function drawAxes() {
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // 축 라벨(x축 라벨, y축 라벨)
        function drawLabels() {
            ctx.textAlign = "center";
            ctx.font = "bold 12px Arial";

            ctx.fillStyle = datasets[0].borderColor;
            ctx.fillText(`리부트1 인구(명)`, width / 2 - 50, height / 10);

            ctx.fillStyle = datasets[1].borderColor;
            ctx.fillText(`리부트2 인구(명)`, width / 2 + 50, height / 10);

            // x축 라벨(연도)
            for(let i = 0; i < labels.length; i++) {
                const x = padding + xStep  * i;
                const y = height - padding + 20;
                ctx.fillStyle = "#000";
                ctx.fillText(labels[i], x, y);
            }

            // y축 라벨(데이터 세트)
            const yStep = (maxValue - minValue) / labels.length;
            ctx.fillStyle = "#000";
            ctx.textAlign = "right";
            ctx.font = "8px";

            for(let i = 0; i <= labels.length ; i++) {
                const y = padding + chartHeight - ((yStep * i) / (maxValue - minValue)) * chartHeight;
                ctx.fillText((minValue + yStep * i).toFixed(0), padding - 10, y + 5);

                // 가로선 그리기
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.strokeStyle = `rgba(0, 0, 0, 0)`;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }
        // 세로선 그리기
        function drawGridLines() {
            ctx.strokeStyle = `rgba(0, 0, 0, 0.1)`;
            ctx.lineWidth = 1;
            for(let i = 0; i < labels.length; i++) {
                const x = padding + xStep * i;
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, height - padding);
                ctx.stroke();
            }
        }

        // 툴팁 표시
        function showTooltip(event) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            for(let i = 0; i < labels.length; i++) {
                const { x, y } = getCanvasCoordinates(0, i);
                if(Math.abs(mouseX - x) < 5) {
                    tooltip.style.left = `${x}px`;
                    tooltip.style.top = `${y - 30}px`;
                    tooltip.innerHTML = `${labels[i]}<br>${datasets[0].label}: ${datasets[0].data[i]}<br>${datasets[1].label}: ${datasets[1].data[i]}`;
                    tooltip.style.display = "block";
                    return;
                }
            }
            tooltip.style.display = "none";
        }

        // 애니메이션
        canvas.addEventListener("mousemove", showTooltip);
        startTime = performance.now();
        currentPointIndex = 0;
        progress = 0;
        requestAnimationFrame(animateChart);
    }
</script>
</html>